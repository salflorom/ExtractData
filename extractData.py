# Author: Santiago A. Flores Roman
# Description: This script extracts the requested data from the data files generated by RASPA.
# Requirements: Numpy, Pandas and matplotlib have to be installed.
# Instructions: 
#   This script assumes that there is only one data file per Output/System_#/ directory. The reason
#   is that several points can be run at the same time in Slurm, acceleating the simulation. If there
#   are several data files in one directory, then RASPA will have simulated point by point, which is 
#   slow as the program is not parallelized.
#   Run the script as following for more information.
#   python3 extractRaspaData.py -h 

import os,re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sys import argv,exit
##########################################################################################################
class Extract():
    def __init__(self,argv):
        self.argv = argv
        self.motor = 'Raspa'
        self.path = './Outputs/System_0/'
        self.units = 'kPa'
        self.sort = 'P'
        self.sections = ['prod']
        self.dimensions = ['x','y','z']
        self.varsToExtract = ['Rho','P']
        self.components, self.listInFiles, self.outFilePath = [], [], []
        self.outFile = ('outData.dat',False)
        self.printInputParams = self.createFigures = False
        self.fileLines = self.fileNumber = 0
        self.fileName, self.dimLetter = '', ''
    def Flags(self):
        argv = self.argv
        printInputParams = self.printInputParams
        createFigures = self.createFigures
        path = self.path
        units = self.units
        sort = self.sort
        outFile = self.outFile
        dimensions = self.dimensions
        components = self.components
        varsToExtract = self.varsToExtract
        sections = self.sections
        motor = self.motor
        for i in range(len(argv)):
            argv[i] = argv[i].lower()
            if (argv[i] == '-h'): self.Help()
            elif (argv[i] == '-p'): printInputParams = True
            elif (argv[i] == '-f'): createFigures = True
            elif (argv[i] == '-i'): path = argv[i+1]
            elif (argv[i] == '-u'): units = argv[i+1]
            elif (argv[i] == '-s'): sort = argv[i+1]
            elif (argv[i] == '-o'): outFile = (argv[i+1],True)
            elif (argv[i] == '-m'): motor = argv[i+1]
            elif (argv[i] == '-d'): 
                dimensions = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    dimensions.append(argv[j])
            elif (argv[i] == '-c'): 
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    components.append(argv[j])
            elif (argv[i] == '-v'): 
                varsToExtract = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    varsToExtract.append(argv[j].lower())
            elif (argv[i] == '-t'): 
                sections = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    sections.append(argv[j])
        self.printInputParams = printInputParams
        self.createFigures = createFigures
        self.path = path
        self.units = units
        self.sort = sort
        self.outFile = outFile
        self.dimensions = dimensions
        self.components = components
        self.varsToExtract = varsToExtract
        self.sections = sections
    def CreateDataFrame(self,outData):
        dimensions = self.dimensions
        sort = self.sort
        keys = list(outData.keys())
        longestKey = keys[0]
        for i in range(1,len(keys)): # Use a python's library!
            if (len(outData[keys[i]]) > len(outData[keys[i-1]])): longestKey = keys[i]
        outData = pd.DataFrame(outData,index=range(len(outData[longestKey])))
        for key in outData.columns:
            findSortKey = re.search(f'^{sort}\[.+',key)
            if findSortKey: 
                outData.sort_values(findSortKey.group(),ignore_index=True,inplace=True); break
        return outData
    def CreateOutFile(self,outData,fileNumber):
        outPath, outFileName, outExtension = self.outFilePath
        if outPath: outPath = f'{outPath}dataFiles/' #If output file is in a subdirectory.
        else: outPath = 'dataFiles/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        outData.to_csv(f'{outPath}{fileNumber}_{outFileName}{outExtension}',sep='\t',index=False,na_rep='NaN')
    def ReadOutputFile(self):
        outFile = self.outFile
        outFilePath = re.search(r'^(.+/)?(.+)(\..+)$',outFile[0])
        if not outFilePath.group(3): 
            outFilePath = (outFilePath.group(1),outFilePath.group(2),'.dat')
        else: 
            outFilePath = outFilePath.group(1,2,3)
        self.outFilePath = outFilePath
        return outFilePath
    def PlotVariables(self,outData,fileNumber):
        outPath,outFileName,outExtension = self.outFilePath
        outData.plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
        plt.tight_layout()
        if outPath: outPath += 'Figures/' #If output file is in a subdirectory.
        else: outPath = 'Figures/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        plt.savefig(f'{outPath}{fileNumber}_{outFileName}.pdf')
    def ExtractData(self):
        listInFiles = self.listInFiles
        path = self.path
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        for i in range(len(listInFiles)):
            print('\nExtracting data...')
            outData = self.CallExtractors(listInFiles[i]) # From derived class.
            print('\nOrganizing data...')
            outData = self.CreateDataFrame(outData)
            print(outData)
            print(outData.describe())
            if createOutFile:
                outPath, outFileName, outExtension = self.ReadOutputFile()
                if outPath:
                    print(f'\nCreating output file: {outPath}dataFiles/{i}_{outFileName}{outExtension} ...')
                else: 
                    print(f'\nCreating output file: dataFiles/{i}_{outFileName}{outExtension} ...')
                self.CreateOutFile(outData,i)
                if createFigures: 
                    print('\nCreating figures...')
                    self.PlotVariables(outData,i)
            else:
                if createFigures: 
                    _ = self.ReadOutputFile()
                    print('\nCreating figures...')
                    self.PlotVariables(outData,i)
            print(f'\nNormal termination for file {listInFiles[i]}')
        print(f'\nNormal termination.')
        exit(0)
class Raspa(Extract):
    def __init__(self): Extract.__init__(self,argv)
    def FindComponents(self,inputFileName):
        with open(inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findLine = re.search('Amount of molecules per component:',fileLines[line])
            if findLine: 
                for subline in range(line+2,len(fileLines)):
                    findDashedLine = re.search('---',fileLines[subline])
                    if findDashedLine: break
                    findComponent = re.search('Component\s+?\d+\s+?\((.+?)\)',fileLines[subline])
                    self.components.append(findComponent.group(1))
                break
    def ReadInputFiles(self):
        argv = self.argv
        path = self.path
        listInFiles = os.listdir(path)
        self.listInFiles = listInFiles
        self.FindComponents(path+listInFiles[0])
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        dimensions = self.dimensions
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        components = self.components
        units = self.units
        sections = self.sections
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tFluid components: {components}')
        print(f'\tPressure unit: {units}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tSections to analyze: {sections}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        print(f'\tInput files:')
        for i in range(len(listInFiles)):
            print(f'\t\t{listInFiles[i]}')
        if createOutFile: 
            print(f'\t\tOutput files:')
            for i in range(len(listInFiles)):
                print('{i}_{outFileName}')
    def CallExtractors(self,fileName):
        path = self.path
        varsToExtract = self.varsToExtract
        components = self.components
        dimensions = self.dimensions
        units = self.units
        sections = self.sections
        outData = {}
        with open(path+fileName,'r') as fileContent: fileLines = fileContent.readlines()
        if ('v' in varsToExtract): outData['V[A^3]'] = self.ExtractVolumes(fileLines)
        if ('t' in varsToExtract): outData['T[K]'] = self.ExtractTemperatures(fileName,fileLines)
        if ('p' in varsToExtract): outData[f'P[{units}]'] = self.ExtractPressures(fileName,fileLines)
        if ('u' in varsToExtract): outData['U[K]'] = self.ExtractInternalEnergy(fileLines)
        if ('mu' in varsToExtract): 
            for comp in components:
                chemPots,deltaChemPots = self.ExtractWidomChemicalPotential(fileLines,comp)
                outData['Mu[K]'+f' {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData['deltaMu[K]'+f' {comp}'] = deltaChemPots
        if ('idmu' in varsToExtract): 
            for comp in components:
                chemPots,deltaChemPots = self.ExtractIdealWidomChemicalPotential(fileLines,comp)
                outData['IdMu[K]'+f' {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData['deltaIdMu[K]'+f' {comp}'] = deltaChemPots
        if ('exmu' in varsToExtract): 
            for comp in components:
                chemPots,deltaChemPots = self.ExtractExcessWidomChemicalPotential(fileLines,comp)
                outData['ExMu[K]'+f' {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData['deltaExMu[K]'+f' {comp}'] = deltaChemPots
        if ('rho' in varsToExtract): 
            for comp in components:
                outData['Rho[kg/m^3]'+f' {comp}'] = self.ExtractDensities(fileLines,comp)
        if ('n' in varsToExtract): 
            for comp in components:
                outData['N'+f' {comp}'] = self.ExtractNumberOfMolecules(fileLines,comp)
        if ('l' in varsToExtract): 
            for dim in dimensions:
                outData['Box-L[A]'+f' {dim}'] = self.ExtractBoxLengths(fileLines,dim)
        return outData
    def ExtractVolumes(self,fileLines):
        sections = self.sections
        volumes = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findVolume = re.search(r'^Volume:\s+(\d+\.?\d*)\s+\[A\^3\]$',fileLines[line])
                    if findVolume: volumes.append(float(findVolume.group(1))) #A^3
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findVolume = re.search(r'Volume:\s+(\d+\.?\d*).+Average\s+Volume:',fileLines[line])
                    if findVolume: volumes.append(float(findVolume.group(1))) #A^3
        return pd.Series(volumes,index=range(len(volumes)))
    def ExtractPressures(self,fileName,fileLines):
        units = self.units
        sections = self.sections
        pressures = []
        for sec in sections:
            if (sec.lower() == 'init'): print('Warning: Pressure is not calculated by RASPA during initialization and equilibration cycles.')
            else:
                for line in range(len(fileLines)):
                    findPressure = re.search(f'Average pressure:.+?(\d+\.\d*)\s+\[{units}\]',fileLines[line])
                    if (findPressure and float(findPressure.group(1)) != 0.0): pressures.append(float(findPressure.group(1)))
        if (len(pressures) == 0):
            print('No molecular pressures were found. Extracting fixed external pressure.')
            findPressure = re.search(f'.+_(\d+\.?\d*e?\+?\d*)\.data',fileName)
            if units == 'bar': pressures.append(float(findPressure.group(1))*1e-5)
            elif units == 'atm': pressures.append(float(findPressure.group(1))*9.896e-6)
            else: pressures.append(float(findPressure.group(1))*1e-3) #kPa
        return pd.Series(pressures,index=range(len(pressures)))
    def ExtractTemperatures(self,fileName,fileLines):
        sections = self.sections
        temperatures = []
        for sec in sections:
            if (sec.lower() == 'init'):
                print('Warning: Temperature is not calculated by RASPA during initialization cycles.')
                for line in range(len(fileLines)):
                    findTemperature = re.search(f'^Temperature:\s+(\d+\.?\d*)$',fileLines[line])
                    if findTemperature: temperatures.append(float(findTemperature.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findTemperature = re.search(f'Temperature:\s+(\d+\.?\d*).+Translational',fileLines[line])
                    if findTemperature: temperatures.append(float(findTemperature.group(1)))
            if (len(temperatures) == 0):
                print('No molecular temperatures were found. Extracting fixed external temperatures.')
                temperatures.append(float(re.search('.+_(\d+\.?\d*)_\d+\.?\d*e?\+?\d*\.data',fileName).group(1)))
        return pd.Series(temperatures,index=range(len(temperatures)))
    def ExtractInternalEnergy(self,fileLines):
        sections = self.sections
        energies,deltaEnergies = [],[]
        for sec in sections:
            if (sec.lower() == 'init'):
                print('Warning: Internal energy is not calculated by RASPA during initialization, equilibration and production cycles.')
                print('Conserved energy will be extracted. It is calculated after initialization cycles (from equilibration and production cycles).')
                for line in range(len(fileLines)):
                    findEnergy = re.search(f'^Conserved\senergy:\s+(-?\d+\.?\d*)',fileLines[line])
                    if findEnergy: energies.append(float(findEnergy.group(1)))
                if (len(energies) == 0):
                    print('Warning: There was no conserved energy to extract. Extracting current energies per cycle.')
                    currentEnergies = []
                    for line in range(len(fileLines)):
                        currentEnergy = re.search(f'Current.+energy:\s+(-?\d+\.?\d*)',fileLines[line])
                        lastCurrentEnergy = re.search(f'Current Adsorbate-Cation energy:\s+(-?\d+\.?\d*)',fileLines[line])
                        if lastCurrentEnergy: 
                            currentEnergies.append(float(lastCurrentEnergy.group(1)))
                            energies.append(sum(currentEnergies))
                            currentEnergies = []
                        elif currentEnergy: currentEnergies.append(float(currentEnergy.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findEnergy = re.search(f'Total energy:',fileLines[line])
                    if findEnergy:
                        energy = re.search(f'Average\s+(-?\d+\.\d+).+?(\d+\.\d+)',fileLines[line+8])
                        energies.append(float(energy.group(1))) #J/kb
                        deltaEnergies.append(float(energy.group(2))) #J/kb
                        break
                if not findEnergy:
                    print('Error: Tried to read internal energy, but simulation hasn\'t ended properly.')
                    print('Extracting current energies per cycle.')
                    currentEnergies = []
                    for line in range(len(fileLines)):
                        currentEnergy = re.search(f'Current.+energy:\s+(-?\d+\.?\d*).+avg\.',fileLines[line])
                        lastCurrentEnergy = re.search(f'Current Adsorbate-Cation energy:\s+(-?\d+\.?\d*).+avg\.',fileLines[line])
                        if lastCurrentEnergy: 
                            currentEnergies.append(float(lastCurrentEnergy.group(1)))
                            energies.append(sum(currentEnergies))
                            currentEnergies = []
                        elif currentEnergy: currentEnergies.append(float(currentEnergy.group(1)))
        if (len(energies) == 0): 
            print('Warning: No energy was found from RASPA.'); energies.append(np.nan)
        if (len(deltaEnergies) == 0): deltaEnergies.append(np.nan)
        return pd.Series(energies,index=range(len(energies))),pd.Series(deltaEnergies,index=range(len(deltaEnergies)))
    def ExtractDensities(self,fileLines,component):
        sections = self.sections
        densities = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findDensity = re.search(f'Component.+\({component}\).+density:\s+(\d+\.?\d*)\s+\[kg',fileLines[line])
                    if findDensity: densities.append(float(findDensity.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findDensity = re.search(f'Component.+\({component}\).+density:\s+(\d+\.?\d*)\s+\(',fileLines[line])
                    if findDensity: densities.append(float(findDensity.group(1))) #kg/m^3
        return pd.Series(densities,index=range(len(densities)))
    def ExtractBoxLengths(self,fileLines,dimLetter):
        sections = self.sections
        dimension = {'x':1,'y':2,'z':3}
        boxLengths = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findLength = re.search(f'Box-lengths:\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+Box-angles',fileLines[line])
                    if findLength: boxLengths.append(float(findLength.group(dimension[dimLetter]))) #A
            if (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findLength = re.search(f'Box-lengths:\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*).+Average',fileLines[line])
                    if findLength: boxLengths.append(float(findLength.group(dimension[dimLetter]))) #A
        return pd.Series(boxLengths,index=range(len(boxLengths)))
    def ExtractNumberOfMolecules(self,fileLines,component):
        sections = self.sections
        nMolecules = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findAmountMolecules = re.search(f'Component.+\({component}\).+molecules:\s+(\d+)/\d+/\d+,',fileLines[line])
                    if findAmountMolecules: nMolecules.append(float(findAmountMolecules.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findAmountMolecules = re.search(f'Component.+\({component}\).+molecules:\s+(\d+)/.+\(',fileLines[line])
                    if findAmountMolecules: nMolecules.append(float(findAmountMolecules.group(1)))
        return pd.Series(nMolecules,index=range(len(nMolecules)))
    def ExtractWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search(f'Average Widom chemical potential:',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\]\s+Average.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot: 
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findChemPot = re.search(f'Component\s+\[{component}\].+average chemical potential:\s+(-?\d+\.?\d*)',fileLines[line]) #J/kb
                        if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0): 
            print('Warning: None chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))
    def ExtractIdealWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Ideal-gas Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search('Average Widom Ideal-gas contribution',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\].+Ideal-gas.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot: 
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read ideal-gas chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current ideal-gas chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findWidom = re.search(f'Component \[{component}\] average Widom',fileLines[line])
                        if findWidom:
                            findChemPot = re.search('ideal-gas.+?(-?\d+\.?\d*)',fileLines[line+1]) #J/kb
                            if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0): 
            print('Warning: None ideal-gas chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))
    def ExtractExcessWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Excess Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search('Average Widom excess contribution',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\].+excess chemical.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot: 
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read excess chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current excess chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findWidom = re.search(f'Component \[{component}\] average Widom',fileLines[line])
                        if findWidom:
                            findChemPot = re.search('excess chemical.+?(-?\d+\.?\d*)',fileLines[line+1]) #J/kb
                            if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0): 
            print('Warning: None excess chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))
class Chainbuild(Extract):
    def __init__(self): 
        Extract.__init__(self,argv)
        self.listLogFiles = []
        self.solidFileName = ''
        self.molFileName = ''
        self.sigma_ff = self.epsilon_ff = 0
    def ReadInputFiles(self):
        path = self.path
        listInputFiles, listLogFiles = [], []
        molFileFound = False 
        for fileName in os.listdir(path):
            if fileName.endswith('.inp'): listInputFiles.append(fileName)
            elif fileName.endswith('.log'): listLogFiles.append(fileName)
            elif fileName.endswith('.sol'): self.solidFileName = fileName 
            elif fileName.endswith('.mol'): 
                self.molFileName = fileName
                self.ExtractLennardJonesParameters(path+fileName)
                molFileFound = True 
        if not molFileFound: print('Error: Molecule file not found. Exiting.'); exit(2)
        listInputFiles.sort(); listLogFiles.sort()
        self.listInFiles = listInputFiles
        self.listLogFiles = listLogFiles
    def ExtractLennardJonesParameters(self,molFileName):
        with open(molFileName,'r') as molFile: molFileLines = molFile.readlines()
        for line in molFileLines:
            findSigma = re.search(r'sigma1?\s+(\d+\.?\d*)',line)
            findEpsilon = re.search(r'epsilon\s+(\d+\.?\d*)',line)
            if findSigma: self.sigma_ff = float(findSigma.group(1))
            if findEpsilon: self.epsilon_ff = float(findEpsilon.group(1))
        if not (self.sigma_ff and self.epsilon_ff): print('Lennard Jones parameters not found. Exiting.'); exit(2)
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        dimensions = self.dimensions
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        sections = self.sections
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tSections to analyze: {sections}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        print(f'\tInput files:')
        for i in range(len(listInFiles)):
            print(f'\t\t{listInFiles[i]}')
    def CallExtractors(self,inputFileName):
        varsToExtract = self.varsToExtract
        components = self.components
        dimensions = self.dimensions
        units = self.units
        sections = self.sections
        listLogFiles = self.listLogFiles
        logFileName = ''
        for logFile in listLogFiles:
            if logFile[:-4] == inputFileName[:-4]: 
                logFileName = logFile; break
        if not logFileName: print(f'Log file {inputFileName[:-4]}.log not found. Exiting.'); exit(2)
        outData = {}
        if ('v' in varsToExtract): outData['V[A^3]'] = self.ExtractVolumes(inputFileName)
        if ('t' in varsToExtract): outData['T[K]'] = self.ExtractTemperatures(inputFileName)
        if ('uff' in varsToExtract): outData['Uff[K]'] = self.ExtractFluidFluidEnergy(logFileName)
        if ('usf' in varsToExtract): outData['Usf[K]'] = self.ExtractSolidFluidEnergy(logFileName)
        if ('idmu' in varsToExtract): outData['IdMu[K]'] = self.ExtractIdealWidomChemicalPotential(logFileName)
        if ('mu' in varsToExtract): outData['Mu[K]'] = self.ExtractChemicalPotential(inputFileName,logFileName)
        if ('rho' in varsToExtract): outData['Rho[A^-3]'] = self.ExtractDensities(inputFileName,logFileName)
        if ('n' in varsToExtract): outData['N'] = self.ExtractNumberOfMolecules(inputFileName,logFileName)
        if ('l' in varsToExtract): 
            for dim in dimensions:
                outData['Box-L[A]'+f' {dim}'] = self.ExtractBoxLengths(inputFileName,dim)
        return outData
    def ExtractChemicalPotential(self,inputFileName,logFileName):
        path = self.path
        eps = self.epsilon_ff #K
        chemPots = []
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findEnsemble = re.search(f'ens\s+(\w+)\s+?(-?\d+\.?\d*)',fileLines[line])
            if findEnsemble: 
                if findEnsemble.group(1) == 'gce':
                    print('Ensemble is \"GCE\". Reading chemical potentials input file.')
                    chemPots.append(float(findEnsemble.group(2)))
                elif findEnsemble.group(1) == 'nvt':
                    print('Ensemble is \"NVT\". Reading excess chemical potentials from log file.')
                    with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
                    for line in range(len(fileLines)):
                        findChemPot = re.search(f'mu_ex=\s+(-?\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
                        if findChemPot: chemPots.append(float(findChemPot.group(1)))
                break
        if (len(chemPots) == 0): 
            print('Warning: Chemical potential was not found from Chainbuild'); chemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots)))*eps #K
    def ExtractIdealWidomChemicalPotential(self,logFileName):
        path = self.path
        epsilon = self.epsilon_ff #K
        with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
        chemPots = []
        for line in range(len(fileLines)-1,0,-1):
            findChemPot = re.search(f'<mu_incr>=\s+(-?\d+\.?\d*\w?-?\d*)',fileLines[line])
            if findChemPot: 
                chemPots.append(float(findChemPot.group(1))); break #J/(kb*eps_ff)
        if (len(chemPots) == 0): 
            print('Warning: Tried to read ideal chemical potential, but simulation hasn\'t ended properly.')
            print('Warning: None ideal chemical potential was not found from Chainbuild.'); chemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots)))*epsilon #K
    def ExtractFluidFluidEnergy(self,logFileName):
        path = self.path
        epsilon = self.epsilon_ff #K
        with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
        print('Extracting current fluid-fluid energies per cycle.')
        energies = []
        for line in range(len(fileLines)):
            findEnergy = re.search(r'Uff=\s+(-?\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
            if findEnergy: energies.append(float(findEnergy.group(1))) #J/(kb*eps_ff)
        if (len(energies) == 0): 
            print('Warning: No fluid-fluid energy was not found from Chainbuild.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))*epsilon #K
    def ExtractSolidFluidEnergy(self,logFileName):
        path = self.path
        epsilon = self.epsilon_ff #K
        with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
        print('Extracting current solid-fluid energies per cycle.')
        energies = []
        for line in range(len(fileLines)):
            findEnergy = re.search(r'Usf=\s+(-?\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
            if findEnergy: energies.append(float(findEnergy.group(1))) #J/(kb*eps_ff)
        if (len(energies) == 0): 
            print('Warning: No solid-fluid energy was not found from Chainbuild.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))*epsilon #K
    def ExtractNumberOfMolecules(self,inputFileName,logFileName):
        path = self.path
        nMolecules = []
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findNMolecules = re.search(r'ens\s+(\w+)\s+?(-?\d+\.?\d*)',fileLines[line])
            if findNMolecules: 
                if findNMolecules.group(1) == 'nvt':
                    print('Ensemble is \"NVT\". Reading number of molecules from input file.')
                    nMolecules.append(float(findNMolecules.group(2)))
                elif findNMolecules.group(1) == 'gce':
                    print('Ensemble is \"GCE\". Reading number of molecules from log file.')
                    with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
                    for line in range(len(fileLines)):
                        findNMolecules = re.search(f'N=\s+(\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
                        if findNMolecules: nMolecules.append(float(findNMolecules.group(1)))
                break
        if (len(nMolecules) == 0): 
            print('Warning: Number of molecules was not found from Chainbuild'); nMolecules.append(np.nan)
        return pd.Series(nMolecules,index=range(len(nMolecules)))
    def ExtractBoxLengths(self,inputFileName,dimLetter):
        path = self.path
        sigma = self.sigma_ff #Angstrom
        solidFileName = self.solidFileName
        boxLengths = []
        print('Warning: Lenghts are not calculated by Chainbuild during simulation.')
        print('Conserved lengths will be extracted.')
        if solidFileName:
            dimension = {'x':1,'y':2,'z':3}
            with open(path+solidFileName,'r') as solidFile: fileLines = solidFile.readlines()
            for line in range(len(fileLines)):
                findLength = re.search(r'(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)',fileLines[line])
                if findLength: 
                    boxLengths.append(float(findLength.group(dimension[dimLetter]))); break #nm/sigma_ff
        elif inputFileName:
            with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
            for line in range(len(fileLines)):
                findLengths = re.search(r'solid.+?(-?\d+\.?\d*)',fileLines[line])
                if findLengths: 
                    boxLengths.append(float(findLengths.group(1))); break #nm/sigma_ff
        if len(boxLengths) == 0:
            print('Error: Given lengths were not found.'); volume.append(np.nan)
        return pd.Series(boxLengths,index=range(len(boxLengths)))*sigma #Angstrom
    def ExtractVolumes(self,inputFileName):
        path = self.path
        sigma = self.sigma_ff #Angstrom
        solidFileName = self.solidFileName
        volume = []
        print('Warning: Volume is not calculated by Chainbuild during simulation.')
        print('Conserved volume will be extracted.')
        if solidFileName:
            with open(path+solidFileName,'r') as solidFile: fileLines = solidFile.readlines()
            for line in range(len(fileLines)):
                findLengths = re.search(r'(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)',fileLines[line])
                if findLengths:
                    xLength = float(findLengths.group(1))
                    yLength = float(findLengths.group(2))
                    zLength = float(findLengths.group(3))
                    volume.append(xLength*yLength*zLength) #(nm/sigma_ff)^3
                    break
        elif inputFileName:
            with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
            for line in range(len(fileLines)):
                findLengths = re.search(r'solid.+?(-?\d+\.?\d*)',fileLines[line])
                if findLengths:
                    length = float(findLengths.group(1)) #(nm/sigma_ff)^3
                    volume.append(length**3)
                    break
        if len(volume) == 0:
            print('Error: Volume was not found.'); volume.append(np.nan)
        return pd.Series(volume,index=range(len(volume)))*sigma**3 #A^3
    def ExtractTemperatures(self,inputFileName):
        path = self.path
        print('Warning: Temperature is not calculated by Chainbuild during simulation.')
        print('External temperature will be extracted.')
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        temperature = []
        for line in range(len(fileLines)):
            findTemperature = re.search(r'ens.+?\d+\.?\d*\s+(-?\d+\.?\d*)',fileLines[line])
            if findTemperature:
                temperature.append(float(findTemperature.group(1))); break
        if len(temperature) == 0:
            print('Error: Temperature was not found.'); temperature.append(np.nan)
        return pd.Series(temperature,index=range(len(temperature))) #K
    def ExtractDensities(self,inputFileName,logFileName):
        path = self.path
        sigma = self.sigma_ff #Angstrom
        density = []
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findEnsemble = re.search(f'ens\s+(\w+)\s+?(-?\d+\.?\d*)',fileLines[line])
            if findEnsemble: 
                if findEnsemble.group(1) == 'nvt':
                    print('Ensemble is \"NVT\". Density is not given, but you can calculate it manually.')
                    density.append(np.nan)
                elif findNMolecules.group(1) == 'gce':
                    print('Ensemble is \"GCE\". Reading density from log file.')
                    print('Warning: Density is not calculated by Chainbuild during simulation.')
                    print('Final density will be extracted.')
                    with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
                    for line in range(len(fileLines)):
                        findDensity = re.search(f'<rho>=\s+(\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
                        if findDensity: density.append(float(findDensity.group(1)))
                    if (len(density) == 0): 
                        print('Warning: Density was not found from Chainbuild'); density.append(np.nan)
                break
        return pd.Series(density,index=range(len(density)))/sigma**3 #Angstrom^-3
class SummarizeDataFrames():
    def __init__(self,dataFilesPath,groups,sort,joinDataFrames,countFrom):
        self.dataFilesPath = dataFilesPath
        self.groups = groups.split()
        self.joinDataFrames = joinDataFrames
        self.countDataFrom = countFrom
        self.sortDataFramesBy = sort
        self.summedDataFrame, self.summedDataFrames, self.groupedDataFrames = {}, {}, {}
    def SearchDataFiles(self):
        dataFilesPath = self.dataFilesPath
        groups = self.groups
        countFrom = self.countDataFrom
        dataFileNames = os.listdir(dataFilesPath)
        groupedDataFrames = {i:[] for i in groups}
        for dataFile in dataFileNames:
            dataFrame = pd.read_csv(dataFilesPath+dataFile,sep='\t')
            dfFirstRow = dataFrame[:1]
            dataFrame = pd.concat([dfFirstRow,dataFrame[countFrom:]])
            for i in groups:
                if re.search(i,dataFile): groupedDataFrames[i].append(dataFrame)
        self.groupedDataFrames = groupedDataFrames
    def JoinDataFrames(self):
        sort = self.sortDataFramesBy
        dataFrames = self.summedDataFrames
        concatDataFrame = pd.concat(dataFrames).reset_index()
        concatDataFrame.drop(columns={'level_1'},inplace=True)
        concatDataFrame.rename(columns={'level_0':'Group'},inplace=True)
        for key in concatDataFrame.columns:
            findSortValue = re.search(f'^{sort}\[.+',key)
            if findSortValue: concatDataFrame.sort_values(findSortValue.group(),ignore_index=True,inplace=True)
        print('Data Frame:\n')
        print(concatDataFrame)
        self.summedDataFrame = concatDataFrame
    def SetSummedDataFrames(self):
        groups = self.groups
        summedDataFrames = self.summedDataFrames
        for i in groups: summedDataFrames[i] = pd.DataFrame(columns=[])
        self.summedDataFrames = summedDataFrames
    def CreateSummedDataFrames(self):
        sort = self.sortDataFramesBy
        groups = self.groups
        groupedDataFrames = self.groupedDataFrames
        summedDataFrames = self.summedDataFrames
        for i in groups:
            for var in groupedDataFrames[i][0].columns:
                summedDataFrames[i][var] = pd.Series([groupedDataFrames[i][j][var].mean() for j in range(len(groupedDataFrames[i]))])
                summedDataFrames[i][f'delta{var}'] = pd.Series([groupedDataFrames[i][j][var].std() for j in range(len(groupedDataFrames[i]))])
            summedDataFrames[i].sort_values(sort,ignore_index=True,inplace=True)
        self.summedDataFrames = summedDataFrames
    def Extract(self):
        self.SearchDataFiles()
        self.SetSummedDataFrames()
        self.CreateSummedDataFrames()
        dataFrames = self.summedDataFrames
        groups = self.groups
        for i in groups:
            print('\n'+i)
            print(dataFrames[i])
def SumUpDataFrames(dataFilesPath,groups,sortDataFrames,joinDataFrames,countDataFrom):
    data = SummarizeDataFrames(dataFilesPath,groups,sortDataFrames,joinDataFrames,countDataFrom)
    data.Extract()
    if joinDataFrames:
        data.JoinDataFrames()
        return data.summedDataFrame
    else: return data.summedDataFrames
def Help():
    print('\nDescription:')
    print('\tThis script extracts the output data generated by RASPA or Chainbuild, and saves them as data frames.')
    print('Requirements: Numpy and Pandas libraries must be installed.')
    print('Instructions:')
    print('\tpython3 extractData.py [-[Flag] [Arguments]] [-[Flag] [Arguments]] ...')
    print('\tFlags allowed for RASPA and Chainbuild:')
    print('\t\t-h or -H: Call for help.')
    print('\t\t\tEquilibration cycles (if added), are included in initialization cycles.')
    print('\t\t-s or -S: Sort data frame according to a given value. By default, it\'s pressure (P).')
    print('\t\t\tIt can be sorted according to only one value, which must be one of the variables given after the flag -v (or -V).')
    print('\t\t-f or -F: Plot the evolution of variables along the cycles.')
    print('\t\t\tThe plot file will be outputFile.pdf, where outputFile is indicated by the -o flag.')
    print('\t\t-p or -P: Print input parameters.')
    print('\t\t-i or -I: Indicate the path where the data file is found. By default: Output/System_0')
    print('\t\t-o or -O: Indicate the "path/fileName" where the extracted data will be printed.')
    print('\t\t\tIf you have several files in the input path given, this script will extract them all and enumerate them as i_fileName, where i is an integer number.')
    print('\t\t\tBy default (if you don\'t set output path), no file is created.')
    print('\t\t-d or -D: List of dimensions to extract the box-lengths. By deafault, the three dimensions.')
    print('\t\t-v or -V: Indicate the list of variables that will be extracted from the RASPA\'s data files (per cycle). By default: Rho and P.')
    print('\tFlags allowed only for RASPA:')
    print('\t\t-t or -T: The types of cycles to analyze: Production cycles (prod) or initialization cycles (init). By default: prod')
    print('\t\t-u or -U: Indicate the units for the pressure (kPa, atm or bar). By default: kPa')
    print('\tVariables allowed for RASPA and Chainbuild:')
    print('\t\tV: Volume in A^3.')
    print('\t\tT: Temperature in K.')
    print('\t\tIdMu: Ideal-gas Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\tL: Box-length in A.')
    print('\t\tN: Number of molecules/atoms.') 
    print('\tVariables allowed only for RASPA:')
    print('\t\tP: Pressure in kPa.')
    print('\t\t\tThree different units can be specified: kPa, atm or bar. By default, kPa.')
    print('\t\tU: Internal energy in K (J/kb).')
    print('\t\tMu: Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\tExMu: Excess Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\tRho: Density in kg/m^3.')
    print('\tVariables allowed only for Chainbuild:')
    print('\t\tUff: Internal energy for fluid-fluid interactions in K (J/kb).')
    print('\t\tUsf: Internal energy for solid-fluid interactions in K (J/kb).')
    print('\t\tMu: Excess Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tIf the ensemble is Grand Canonical, it will extract the given chemical potentials.')
    print('\t\tRho: Density in A^-3.')
    print('Example:')
    print('\tThe following command would extract the volume and internal energy of a methane-benzene binary mixture from Output/System_1 from RASPA,')
    print('\tas well as the pressures (in atm) and the box-length in the x axis.')
    print('\tThe extracted data would be saved in the directory grouped_data, and in the files i_excessProps.dat, where i is a number given by this script.')
    print('\tpython3 extractData.py -m Raspa -I Outputs/System_1/ -o grouped_data/excessProps.dat -t prod -v U V P L -U atm -d x -p -s P')
    print('\tThe following command would extract the volume, number of molecules and fluid-fluid internal energy of nitrogen both from Chainbuild.')
    print('\tThe extracted data would be saved in the directory grouped_data and as files outData.dat, and sorted according to the number of molecules.')
    print('\tpython3 extractData.py -m Chainbuild -I ./ -o ./grouped_data/outData.dat -v V N Uff -p -s N')
    print('Note: The file name usually works as the group name as each file will be numbered according to the fileName given.')
    print('\n')
    print('Once you grouped your data into a single directory, you can use an independent script to sum up the given data and do your own analysis.')
    print('1.- In your script, import this file: import extractData as ed')
    print('2.- Give the following information:')
    print('    \t- string: Path where the data files are located. Let\'s call it "dataFilesPath".')
    print('    \t- string: List of the groups of the extracted data (separated by spaces). Call it "groups".')
    print('    \t- string: The variable that you\'ll use to sort your summed data. Call it "sortDataFrames".')
    print('    \t- string: Indicate from what points you want to do your analysis (to avoid biased data). You can check the extracted figures to see from what points')
    print('    \t     your system has reached equilibrium. Call it "countDataFrom".')
    print('    \t- boolean: Indicate if you want to create a single data frame with your grouped data or separate data frames (one per group). Call it "joinDataFrames"')
    print('3.- Create a dictionary that will contain your summed data: dataFrames = ed.SumUpDataFrames(dataFilesPath, groups, sortDataFrames, countDataFrom, joinDataFrames)')
    print('    If you don\'t join your data frames, each dataFrames\'s key will be a group (fileName), and inside each group, you will have your summed data frame.')
    print('    If you join them all, there will be a single data frame with an extra column called "Group".')
    print('Note: your data frames were created using the library pandas, so you can take advantage of the library to analyze the data.')
    print('The file analyzeData.py is an example of a script that would do an analysis.')
    exit(1)
##########################################################################################################
if __name__ == '__main__':
    print('Author: Santiago A. Flores Roman')
    argvString = ' '.join(argv)
    print(f'\nCommand line being executed:\n{argvString}')
    if re.search(r'-h+',argvString.lower()): Help()
    print(f'\nChecking simulation program...')
    extract = 0
    checkMotor = re.search(r'-m\s+(\w+)\s+',argvString.lower())
    if checkMotor:
        motor = checkMotor.group(1)
        if motor == 'raspa': 
            print('RASPA'); extract = Raspa()
        elif motor == 'chainbuild': 
            print('Chainbuild'); extract = Chainbuild()
        else: print(f'Error: Simulation program not known: {motor}. Exiting.'); exit(2)
    else: print('Error: None simulation program found. Exiting.'); exit(2)
    print('\nReading input parameters...')
    extract.Flags()
    print('\nReading input files...')
    extract.ReadInputFiles()
    if extract.printInputParams == True: 
        print('\nInput parameters:\n')
        extract.PrintInputParameters()
    extract.ExtractData()

# EOS
